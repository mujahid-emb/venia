{"version":3,"sources":["../../src/magento-layout-loader/babel-plugin-magento-layout.js"],"names":["validateConfig","require","addDefault","noop","module","exports","babelPluginMagentoLayout","types","t","validationRan","visitor","Program","exit","programPath","state","config","prod","onWarning","onError","opts","passed","error","reactModuleImports","identifiersInScopeFromModule","reactIdentifier","createElementIdentifier","reduce","acc","importData","bindingName","local","traverse","CallExpression","path","isCECall","isCreateElementCall","element","get","dataMIDPropNode","getProp","value","dataMID","type","isStringLiteral","operations","length","ContainerOperationsProcessor","containerPath","containerMID","program","execute","constructor","Object","assign","step","cachedContainerChildIdent","currentOperation","isDone","operation","getContainerChildIdentifier","containerChildIdent","find","findContainerChildByName","targetChildID","children","matchingChild","child","isElement","isCallExpression","elementIdentifier","node","arguments","name","idPropNode","buildCreateElementCall","props","callee","identifier","memberExpression","elementNode","react","isCompatTag","stringLiteral","callExpression","nullLiteral","insertAdjacentArgumentsNode","position","callPath","targetArg","exprNode","args","targetArgIndex","indexOf","targetIndex","splice","insertElementAdjacentToChild","targetChild","componentPath","targetChildPath","targetContainer","componentIdent","nameHint","extensionNode","removeContainer","remove","removeChild","insertBefore","insertAfter","callExprPath","propName","isObjectExpression","prop","properties","currentPropName","key","reactIdent","createElementIdent","isMemberExpression","matchesPattern","isIdentifier","equals","reModuleSpec","targetImportDecls","filter","isImportDeclaration","moduleSpec","source","test","importDecl","spec","specifiers","push","imported"],"mappings":"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","file":"babel-plugin-magento-layout.js","sourcesContent":["const validateConfig = require('./validateConfig');\nconst { addDefault } = require('babel-helper-module-imports');\n\nconst noop = () => {};\nmodule.exports = babelPluginMagentoLayout;\n\nfunction babelPluginMagentoLayout({ types: t }) {\n    // Babel 6 only let's you read plugin options inside visitors,\n    // so we can't warn about an invalid config until the first file is hit.\n    // TODO: In Babel 7, use config passed in when plugin is first created. For now,\n    // this hacky flag is kept in a closure to prevent us from doing config validation\n    // on every file transformed\n    let validationRan;\n\n    return {\n        visitor: {\n            Program: {\n                // Our plugin could be (and frequently is) running along with other Babel\n                // plugins, including the JSX transform. Babel's visitor merging behavior\n                // will make this plugin susceptible to hard-to-debug plugin/preset ordering\n                // issues. To avoid this entirely, we don't start our work until the depth-first\n                // traversal of the AST completes. On Program:exit, we can safely start our work\n                exit(programPath, state) {\n                    // Babel 6 only let's you read plugin options inside visitors,\n                    // so we can't warn about an invalid config until the first file is hit.\n                    // TODO: In Babel 7, use config passed in when plugin is first created\n                    const {\n                        config,\n                        prod = false,\n                        onWarning = noop,\n                        onError = noop\n                    } = state.opts;\n\n                    if (!validationRan) {\n                        validationRan = true;\n                        if (typeof prod !== 'boolean') {\n                            onError(\n                                `Expected \"prod\" to be a boolean, but received \"${typeof prod}\"`\n                            );\n                        }\n                        if (typeof config !== 'object') {\n                            onError(\n                                `Expected \"config\" to be an object, but received \"${typeof config}\"`\n                            );\n                        }\n\n                        const { passed, error } = validateConfig(config);\n                        if (!passed) {\n                            // Warn about invalid config, but let the compilation\n                            // keep going\n                            onWarning(error);\n                        }\n                    }\n\n                    // We need to find any identifiers in scope that could be used to call\n                    // React's `createElement` function.\n                    const reactModuleImports = identifiersInScopeFromModule(\n                        programPath,\n                        /^react$/\n                    );\n                    const {\n                        reactIdentifier,\n                        createElementIdentifier\n                    } = reactModuleImports.reduce((acc, importData) => {\n                        if (importData.bindingName === 'default') {\n                            acc.reactIdentifier = importData.local;\n                        }\n                        if (importData.bindingName === 'createElement') {\n                            acc.createElementIdentifier = importData.local;\n                        }\n                        return acc;\n                    }, {});\n\n                    // No element creation in this file, so we bail\n                    if (!(reactIdentifier || createElementIdentifier)) {\n                        return;\n                    }\n\n                    // Start the transformation traversal\n                    programPath.traverse({\n                        CallExpression(path) {\n                            const isCECall = isCreateElementCall(\n                                path,\n                                reactIdentifier,\n                                createElementIdentifier\n                            );\n                            if (!isCECall) return;\n\n                            const [element] = path.get('arguments');\n                            const dataMIDPropNode = getProp(path, 'data-mid');\n                            if (!dataMIDPropNode) return;\n\n                            const { value: dataMID, type } = dataMIDPropNode;\n                            if (type !== 'StringLiteral') {\n                                onWarning(\n                                    'Expected \"data-mid\" to be a literal string, ' +\n                                        `but instead found a value of type \"${type}\"`\n                                );\n                            }\n\n                            if (!t.isStringLiteral(element)) {\n                                onWarning(\n                                    '\"data-mid\" found on a Composite Component.' +\n                                        'Only DOM elements(div/span/etc) can be a Layout Container'\n                                );\n                            }\n\n                            const operations = config[dataMID];\n                            // No operations were registered for this Container\n                            if (!(operations && operations.length)) {\n                                return;\n                            }\n\n                            new ContainerOperationsProcessor({\n                                types: t,\n                                operations,\n                                containerPath: path,\n                                containerMID: dataMID,\n                                program: programPath,\n                                reactIdentifier,\n                                createElementIdentifier,\n                                onWarning,\n                                onError\n                            }).execute();\n                        }\n                    });\n                }\n            }\n        }\n    };\n}\n\nclass ContainerOperationsProcessor {\n    constructor({\n        types,\n        operations,\n        containerPath,\n        containerMID,\n        program,\n        reactIdentifier,\n        createElementIdentifier,\n        onWarning,\n        onError\n    }) {\n        Object.assign(this, {\n            types,\n            operations,\n            containerPath,\n            containerMID,\n            program,\n            reactIdentifier,\n            createElementIdentifier,\n            onWarning,\n            onError\n        });\n        this.step = 0;\n        this.cachedContainerChildIdent = null;\n    }\n\n    get currentOperation() {\n        return this.operations[this.step];\n    }\n\n    get isDone() {\n        return this.step + 1 > this.operations.length;\n    }\n\n    execute() {\n        while (!this.isDone) {\n            this[this.currentOperation.operation]();\n            ++this.step;\n        }\n    }\n\n    /**\n     * Determine the local identifier for Peregrine's `ContainerChild` component.\n     * This method makes the assumption that the module specifier for a Peregrine\n     * import will always be `@magento/peregrine`. Can make this configurable in the\n     * future if necessary.\n     * @returns {string|null}\n     */\n    getContainerChildIdentifier() {\n        const { cachedContainerChildIdent } = this;\n        if (cachedContainerChildIdent) return cachedContainerChildIdent;\n\n        const { program } = this;\n        const containerChildIdent = identifiersInScopeFromModule(\n            program,\n            /^@magento\\/peregrine$/\n        ).find(({ bindingName }) => bindingName === 'ContainerChild');\n\n        if (containerChildIdent) {\n            this.cachedContainerChildIdent = containerChildIdent.local;\n        }\n\n        return this.cachedContainerChildIdent;\n    }\n\n    /**\n     * Given the identifier for a <ContainerChild />, will return a Babel path\n     * for the matching child in the currently-targeted Container\n     * @param {string} name\n     * @returns {Path|null}\n     */\n    findContainerChildByName(targetChildID) {\n        const {\n            containerPath,\n            reactIdentifier,\n            createElementIdentifier\n        } = this;\n        const containerChildIdent = this.getContainerChildIdentifier();\n\n        const [, , ...children] = this.containerPath.get('arguments');\n        const matchingChild = children.find(child => {\n            // TODO: warn when child is not a ContainerChild\n            const isElement =\n                child.isCallExpression() &&\n                isCreateElementCall(\n                    containerPath,\n                    reactIdentifier,\n                    createElementIdentifier\n                );\n            if (!isElement) return;\n\n            // Verify the child is a Peregrine ContainerChild\n            const [elementIdentifier] = child.node.arguments;\n            if (elementIdentifier.name !== containerChildIdent) return;\n\n            const idPropNode = getProp(child, 'id');\n            return idPropNode && idPropNode.value === targetChildID;\n        });\n        return matchingChild || null;\n    }\n\n    /**\n     * Given an element name, and optional props and children,\n     * returns a Node representing a call to React's createElement\n     * @param {string} element Identifier for Composite Component or DOM Element\n     * @param {object=} props\n     * @returns {Node}\n     */\n    buildCreateElementCall(element, props) {\n        const { types: t, reactIdentifier, createElementIdentifier } = this;\n        const callee = createElementIdentifier\n            ? t.identifier(createElementIdentifier)\n            : t.memberExpression(\n                  t.identifier(reactIdentifier),\n                  t.identifier('createElement')\n              );\n        const elementNode = !t.react.isCompatTag(element)\n            ? t.identifier(element) // Composite Component\n            : t.stringLiteral(element); // DOM Element\n        return t.callExpression(callee, [\n            elementNode,\n            props || t.nullLiteral()\n        ]);\n    }\n\n    /**\n     * Within a CallExpression, inserts a new expression AST node\n     * before or after the specified argument\n     * @param {'before'|'after'} position\n     * @param {Path} Babel path for a CallExpression\n     * @param {Node} targetArg AST Node in the arguments array to insert adjacent to\n     * @param {Node} exprNode An AST node representing any expression\n     */\n    insertAdjacentArgumentsNode(position, callPath, targetArg, exprNode) {\n        const { arguments: args } = callPath.node;\n        const targetArgIndex = args.indexOf(targetArg);\n        const targetIndex =\n            position === 'before' ? targetArgIndex : targetArgIndex + 1;\n        args.splice(targetIndex, 0, exprNode);\n    }\n\n    /**\n     * Used for insertBefore/insertAfter operations. Given a before\n     * or after position, locates the target ContainerChild in the\n     * current Container, and inserts an import declaration for an\n     * extension, along with the element in the proper position\n     * @param {'before'|'after'} position\n     */\n    insertElementAdjacentToChild(position) {\n        const { containerPath, currentOperation, onWarning } = this;\n        const { targetChild, componentPath } = currentOperation;\n        const targetChildPath = this.findContainerChildByName(targetChild);\n        if (!targetChildPath) {\n            onWarning(\n                `Attempted to inject a PWA Studio extension, but specified targetChild was not found\\n` +\n                    `operation: ${currentOperation.operation}\\n` +\n                    `targetContainer: ${currentOperation.targetContainer}\\n` +\n                    `targetChild: ${currentOperation.targetChild}`\n            );\n            return;\n        }\n        const componentIdent = addDefault(targetChildPath, componentPath, {\n            nameHint: 'Extension'\n        }).name;\n        // TODO: extensionNode needs to be wrapped in a new ContainerChild,\n        // and an error boundary\n        const extensionNode = this.buildCreateElementCall(componentIdent);\n        this.insertAdjacentArgumentsNode(\n            position,\n            containerPath,\n            targetChildPath.node,\n            extensionNode\n        );\n    }\n\n    removeContainer() {\n        const { isDone, containerPath, containerMID, onWarning } = this;\n        containerPath.remove();\n        if (!isDone) {\n            // TODO: Consider listing the operations that were skipped,\n            // so a developer knows what extensions likely will not work.\n            // An extension operating on a removed container indicates a conflict\n            // between 2 modules\n            onWarning(\n                `A remove operation was executed on Container ` +\n                    `${containerMID}, but other operations were still ` +\n                    'pending on it. This most commonly indicates' +\n                    'a conflict or ordering issue between modules/extensions'\n            );\n        }\n        // Short-circuit operations, since there is no more work to do\n        // on a removed Container\n        this.step = this.operations.length;\n    }\n\n    /**\n     * Remove a ContainerChild inside of a Container\n     */\n    removeChild() {\n        const { currentOperation, onWarning } = this;\n        const { targetChild } = currentOperation;\n        const targetChildPath = this.findContainerChildByName(targetChild);\n        if (!targetChildPath) {\n            onWarning(\n                `Attempted to remove a PWA Studio ContainerChild, but could not locate it\\n` +\n                    'operation: removeChild\\n' +\n                    `targetContainer: ${currentOperation.targetContainer}\\n` +\n                    `targetChild: ${currentOperation.targetChild}\\n`\n            );\n            return;\n        }\n        targetChildPath.remove();\n    }\n\n    /**\n     * Insert an element before the specified ContainerChild\n     */\n    insertBefore() {\n        this.insertElementAdjacentToChild('before');\n    }\n\n    /**\n     * Insert an element after the specified ContainerChild\n     */\n    insertAfter() {\n        this.insertElementAdjacentToChild('after');\n    }\n}\n\n/**\n * Given a Babel path wrapping a call to createElement,\n * will return the value of the specified prop, if present.\n * @param {Path} propsPath\n * @param {string} prop\n * @returns {Node}\n */\nfunction getProp(callExprPath, propName) {\n    const [, props] = callExprPath.get('arguments');\n    // Could be a NullLiteral if the element has no props\n    if (!props.isObjectExpression()) return;\n\n    for (const prop of props.node.properties) {\n        // Key can either be an identifier (.name) or a string literal (.value)\n        const currentPropName = prop.key.value || prop.key.name;\n        if (currentPropName === propName) return prop.value;\n    }\n}\n\n/**\n * Given a Babel path wrapping a CallExpression,\n * returns a boolean indictating whether the path\n * is a call to React's createElement function\n * @param {Path} callExprPath\n * @param {string=} reactIdent String representing the identifier in scope for React\n * @param {string=} createElementIdent String representing the identifier in scope for createElement\n * @returns {bool}\n */\nfunction isCreateElementCall(callExprPath, reactIdent, createElementIdent) {\n    const callee = callExprPath.get('callee');\n    // React.createElement()\n    if (callee.isMemberExpression()) {\n        return callee.matchesPattern(`${reactIdent}.createElement`);\n    }\n\n    // createElement()\n    if (callee.isIdentifier()) {\n        return callee.equals('name', createElementIdent);\n    }\n\n    return false;\n}\n\n/**\n * Given a Babel path wrapping the `Program` node, and\n * a regex for matching against module specifiers, returns\n * named (and default) imports pulled into scope from that\n * module, and their optionally aliased values\n * @param {Path} programPath\n * @param {RegExp} reModuleSpec\n * @returns {Array<{bindingName: string, local: string}>}\n */\nfunction identifiersInScopeFromModule(programPath, reModuleSpec) {\n    const targetImportDecls = programPath.get('body').filter(path => {\n        if (!path.isImportDeclaration()) return;\n        const moduleSpec = path.node.source.value;\n        return reModuleSpec.test(moduleSpec);\n    });\n\n    return targetImportDecls.reduce((acc, importDecl) => {\n        for (const spec of importDecl.node.specifiers) {\n            acc.push({\n                bindingName:\n                    spec.type === 'ImportDefaultSpecifier'\n                        ? 'default'\n                        : spec.imported.name,\n                local: spec.local.name\n            });\n        }\n\n        return acc;\n    }, []);\n}\n"]}