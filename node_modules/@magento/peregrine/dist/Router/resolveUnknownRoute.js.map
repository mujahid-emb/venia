{"version":3,"sources":["../../src/Router/resolveUnknownRoute.js"],"names":["resolveUnknownRoute","opts","route","apiBase","__tmp_webpack_public_path__","remotelyResolveRoute","then","res","type","matched","tempGetWebpackChunkData","rootChunkID","rootModuleID","id","url","URL","fetch","method","credentials","headers","Headers","body","JSON","stringify","query","trim","json","data","urlResolver","pageType","webpackPublicPath","parser","document","createElement","setAttribute","href","manifest","firstCompatibleConfig","Object","values","find","conf","pageTypes","some","Error"],"mappings":"AAAA;;;;;;AAMA,eAAe,SAASA,mBAAT,CAA6BC,IAA7B,EAAmC;AAC9C,UAAM,EAAEC,KAAF,EAASC,OAAT,EAAkBC,2BAAlB,KAAkDH,IAAxD;;AAEA,WAAOI,qBAAqB;AACxBH,aADwB;AAExBC;AAFwB,KAArB,EAGJG,IAHI,CAGCC,OAAO;AACX,YAAI,EAAEA,OAAOA,IAAIC,IAAb,CAAJ,EAAwB;AACpB,mBAAO,EAAEC,SAAS,KAAX,EAAP;AACH;AACD,eAAOC,wBACHH,IAAIC,IADD,EAEHJ,2BAFG,EAGLE,IAHK,CAGA,CAAC,EAAEK,WAAF,EAAeC,YAAf,EAAD,MAAoC;AACvCD,uBADuC;AAEvCC,wBAFuC;AAGvCC,gBAAIN,IAAIM,EAH+B;AAIvCJ,qBAAS;AAJ8B,SAApC,CAHA,CAAP;AASH,KAhBM,CAAP;AAiBH;;AAED;;;;;AAKA,SAASJ,oBAAT,CAA8BJ,IAA9B,EAAoC;AAChC,UAAMa,MAAM,IAAIC,GAAJ,CAAQ,UAAR,EAAoBd,KAAKE,OAAzB,CAAZ;AACA,WAAOa,MAAMF,GAAN,EAAW;AACdG,gBAAQ,MADM;AAEdC,qBAAa,SAFC;AAGdC,iBAAS,IAAIC,OAAJ,CAAY;AACjB,4BAAgB;AADC,SAAZ,CAHK;AAMdC,cAAMC,KAAKC,SAAL,CAAe;AACjBC,mBAAQ;;wCAEoBvB,KAAKC,KAAM;;;;;aAFhC,CAOLuB,IAPK;AADU,SAAf;AANQ,KAAX,EAiBFnB,IAjBE,CAiBGC,OAAOA,IAAImB,IAAJ,EAjBV,EAkBFpB,IAlBE,CAkBGC,OAAOA,IAAIoB,IAAJ,CAASC,WAlBnB,CAAP;AAmBH;;AAED;;;;;;;;AAQA,SAASlB,uBAAT,CAAiCmB,QAAjC,EAA2CC,iBAA3C,EAA8D;AAC1D;AACA;AACA;AACA;AACA,UAAMC,SAASC,SAASC,aAAT,CAAuB,GAAvB,CAAf;AACAF,WAAOG,YAAP,CAAoB,MAApB,EAA4BJ,iBAA5B;AACA,WAAOd,MAAM,IAAID,GAAJ,CAAQ,qBAAR,EAA+BgB,OAAOI,IAAtC,CAAN,EACF7B,IADE,CACGC,OAAOA,IAAImB,IAAJ,EADV,EAEFpB,IAFE,CAEG8B,YAAY;AACd,cAAMC,wBAAwBC,OAAOC,MAAP,CAAcH,QAAd,EAAwBI,IAAxB,CAA6BC,QAAQ;AAC/D,mBAAOA,KAAKC,SAAL,CAAeC,IAAf,CAAoBnC,QAAQA,SAASqB,QAArC,CAAP;AACH,SAF6B,CAA9B;;AAIA,YAAI,CAACQ,qBAAL,EAA4B;AACxB,kBAAM,IAAIO,KAAJ,CACD,6CAA4Cf,QAAS,EADpD,CAAN;AAGH;;AAED,eAAO;AACHlB,yBAAa0B,sBAAsB1B,WADhC;AAEHC,0BAAcyB,sBAAsBzB;AAFjC,SAAP;AAIH,KAjBE,CAAP;AAkBH","file":"resolveUnknownRoute.js","sourcesContent":["/**\n * @description Given a route string, resolves with the \"standard route\", along\n * with the assigned Root Component (and its owning chunk) from the backend\n * @param {{ route: string, apiBase: string, __tmp_webpack_public_path__: string}} opts\n * @returns {Promise<{matched: boolean, rootChunkID: number | undefined, rootModuleID: number | undefined, id: number }>}\n */\nexport default function resolveUnknownRoute(opts) {\n    const { route, apiBase, __tmp_webpack_public_path__ } = opts;\n\n    return remotelyResolveRoute({\n        route,\n        apiBase\n    }).then(res => {\n        if (!(res && res.type)) {\n            return { matched: false };\n        }\n        return tempGetWebpackChunkData(\n            res.type,\n            __tmp_webpack_public_path__\n        ).then(({ rootChunkID, rootModuleID }) => ({\n            rootChunkID,\n            rootModuleID,\n            id: res.id,\n            matched: true\n        }));\n    });\n}\n\n/**\n * @description Calls the GraphQL API for results from the urlResolver query\n * @param {{ route: string, apiBase: string}} opts\n * @returns {Promise<{type: \"PRODUCT\" | \"CATEGORY\" | \"CMS_PAGE\"}>}\n */\nfunction remotelyResolveRoute(opts) {\n    const url = new URL('/graphql', opts.apiBase);\n    return fetch(url, {\n        method: 'POST',\n        credentials: 'include',\n        headers: new Headers({\n            'Content-Type': 'application/json'\n        }),\n        body: JSON.stringify({\n            query: `\n                {\n                    urlResolver(url: \"${opts.route}\") {\n                        type\n                        id\n                    }\n                }\n            `.trim()\n        })\n    })\n        .then(res => res.json())\n        .then(res => res.data.urlResolver);\n}\n\n/**\n * @description This is temporary until we have proper support in the backend\n * and the GraphQL API for storing/retrieving the assigned Root Component for a route.\n * For now, we fetch the manifest manually, and just grab the first RootComponent\n * that is compatible with the current pageType\n * @param {\"PRODUCT\" | \"CATEGORY\" | \"CMS_PAGE\"} pageType\n * @returns {Promise<{rootChunkID: number, rootModuleID: number}>}\n */\nfunction tempGetWebpackChunkData(pageType, webpackPublicPath) {\n    // In dev mode, `webpackPublicPath` may be a fully qualified URL.\n    // In production mode, it may be a pathname, which makes it unsafe\n    // to use as an API base. Normalize it as a full path using a DOM node\n    // as a native URL parser.\n    const parser = document.createElement('a');\n    parser.setAttribute('href', webpackPublicPath);\n    return fetch(new URL('roots-manifest.json', parser.href))\n        .then(res => res.json())\n        .then(manifest => {\n            const firstCompatibleConfig = Object.values(manifest).find(conf => {\n                return conf.pageTypes.some(type => type === pageType);\n            });\n\n            if (!firstCompatibleConfig) {\n                throw new Error(\n                    `Could not find RootComponent for pageType ${pageType}`\n                );\n            }\n\n            return {\n                rootChunkID: firstCompatibleConfig.rootChunkID,\n                rootModuleID: firstCompatibleConfig.rootModuleID\n            };\n        });\n}\n"]}